# Implementation Plan: AI-Powered Tab Grouping

**Branch**: `001-ai-tab-grouping` | **Date**: 2025-12-23 | **Spec**:
[spec.md](file:///Users/moment/Projects/personal/projects/saas/stop-read/specs/001-ai-tab-grouping/spec.md)\
**Input**: Feature specification from `/specs/001-ai-tab-grouping/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command.

## Summary

Implement AI-powered tab grouping feature for the Stop Read browser extension.
Users can automatically group related tabs based on their learning Goals using
AI analysis, manually organize tabs into custom groups, and manage all tab
groups through a dedicated interface in the options page. The feature leverages
Chrome's native tab groups API for visual indicators and provides drag-and-drop
organization with undo/redo support.

**Technical Approach**: Extend existing Plasmo-based Chrome extension with new
background services for tab group management and AI-powered suggestions. Add
dedicated UI section to options page using React and drag-drop library. Persist
group configurations using existing @plasmohq/storage patterns.

## Technical Context

**Language/Version**: TypeScript 5.3.3 (strict mode)\
**Primary Dependencies**: Plasmo Framework 0.90.5, React 18.2.0,
@plasmohq/storage 1.15.0, @dnd-kit/core 6.1.0, @dnd-kit/sortable 8.0.0\
**Storage**: chrome.storage.sync (tab group configs), chrome.storage.local
(suggestions), @plasmohq/storage wrapper\
**Testing**: Vitest 4.0.16, @testing-library/react 16.3.1\
**Target Platform**: Chrome Extension MV3 (Chrome 88+ for tabGroups API)\
**Project Type**: Chrome Extension (single project structure)\
**Performance Goals**: Support 100+ tabs without lag, <100ms for group
operations, 60 fps drag-drop\
**Constraints**: AI analysis <5s for 20 tabs, storage <5MB for group configs\
**Scale/Scope**: Up to 50 tab groups, 500 tabs total, 20-command undo/redo stack

## Constitution Check

_GATE: Must pass before Phase 0 research. Re-check after Phase 1 design._

### Gates from Constitution v1.0.0

**I. User Journey & Spec-First** ✅ PASS

- Implementation follows prioritized user journeys in spec.md (P1: AI grouping,
  P1: Manage UI, P2: Manual management)
- Each user story independently testable with clear acceptance criteria
- Code will realize the specification documented in research.md, data-model.md,
  and contracts

**II. Test-First Discipline** ✅ PASS

- Plan includes contract tests for all services (Phase 2 tasks)
- Integration tests for storage operations and Chrome API mocking
- Manual UI tests with explicit procedures in quickstart.md
- Will follow Red-Green-Refactor for service development

**III. Atomic & Modular Architecture** ✅ PASS

- Services have single responsibilities: TabGroupService, AIGroupingService,
  TabMetadataService, GroupingCommandService
- Business logic decoupled from UI: background services separate from React
  components
- Small, composable functions planned throughout data-model.md

**IV. Defensive & Observable Implementation** ✅ PASS

- Structured logging via console with context (group ID, operation type)
- Explicit error types defined: TabGroupError with codes (GROUP_NOT_FOUND, etc.)
- Result pattern considered for service responses (ServiceResponse<T>)

**V. Consistency of Truth** ✅ PASS

- Spec → Plan → (upcoming) Tasks workflow ensures sync
- All artifacts reference same entities and requirements
- Version control tracks changes across layers

**Post-Phase 1 Re-check**: ✅ ALL GATES PASSED

## Project Structure

### Documentation (this feature)

```text
specs/001-ai-tab-grouping/
├── spec.md                 # Feature specification
├── plan.md                 # This file
├── research.md             # Technical decisions and rationale
├── data-model.md           # Entity definitions and storage schema
├── quickstart.md           # Setup and testing guide
├── contracts/
│   └── api.md              # Service interface contracts
└── checklists/
    └── requirements.md     # Spec quality validation
```

### Source Code (stop-read-extension/)

```text
stop-read-extension/
├── background/
│   ├── tab-grouping/                    # NEW: Tab grouping background services
│   │   ├── index.ts                     # Export all services
│   │   ├── services/
│   │   │   ├── TabGroupService.ts       # Core group CRUD operations
│   │   │   ├── AIGroupingService.ts     # AI-powered suggestions
│   │   │   ├── TabMetadataService.ts    # Tab metadata management
│   │   │   └── GroupingCommandService.ts # Undo/redo functionality
│   │   ├── handlers/
│   │   │   └── message-handlers.ts      # Chrome message handlers
│   │   └── utils/
│   │       ├── chrome-api-wrapper.ts    # Chrome API abstraction
│   │       └── group-helpers.ts         # Shared utilities
│   └── messages/                         # Existing message handlers
│
├── lib/
│   ├── types/
│   │   └── tab-grouping.ts              # NEW: Type definitions
│   ├── storage/
│   │   └── tab-groups.ts                # NEW: Storage utilities
│   └── llm/                              # Existing AI provider integration
│
├── options/
│   ├── index.tsx                        # MODIFY: Add tab grouping section
│   └── components/
│       └── tab-grouping/                # NEW: Tab grouping UI components
│           ├── TabGroupList.tsx         # List of all groups
│           ├── TabGroupCard.tsx         # Individual group display
│           ├── TabItem.tsx              # Draggable tab item
│           ├── GroupingControls.tsx     # AI grouping & create buttons
│           ├── SuggestionCard.tsx       # AI suggestion display
│           └── UndoRedoControls.tsx     # Undo/redo buttons
│
└── tests/
    └── tab-grouping/                    # NEW: Tab grouping tests
        ├── services/
        │   ├── TabGroupService.test.ts
        │   ├── AIGroupingService.test.ts
        │   ├── TabMetadataService.test.ts
        │   └── GroupingCommandService.test.ts
        └── components/
            ├── TabGroupList.test.tsx
            └── GroupingControls.test.tsx
```

**Structure Decision**: Using Option 1 (Single project) as this is a Chrome
extension with integrated background services and UI. All code lives in
`stop-read-extension/` directory following existing Plasmo framework
conventions.

## Complexity Tracking

> No Constitution violations. All gates passed.

## Implementation Approach

### Phase 1: Core Services & Storage

**Goal**: Implement background services for tab group management without UI.

1. **Create type definitions** (`lib/types/tab-grouping.ts`)
   - Define all interfaces from data-model.md
   - Export ChromeTabGroupColor, SuggestionStatus, CommandType enums

2. **Implement TabGroupService**
   (`background/tab-grouping/services/TabGroupService.ts`)
   - CRUD operations for tab groups
   - Chrome API integration (chrome.tabs.group, chrome.tabGroups.update)
   - Storage persistence using @plasmohq/storage

3. **Implement TabMetadataService**
   (`background/tab-grouping/services/TabMetadataService.ts`)
   - Track tab metadata (URL, title, domain, last accessed)
   - Prune closed tabs
   - Cache management

4. **Implement storage utilities** (`lib/storage/tab-groups.ts`)
   - Storage key constants
   - Helper functions for saving/loading tab groups
   - Migration utilities if needed

5. **Write unit tests** for all services
   - Mock Chrome APIs using vitest.mock
   - Test storage operations with mock storage
   - Verify error handling

**Verification**:

- Run `pnpm test tab-grouping/services` - all tests pass
- Manual: Load extension, use background script console to call service methods
  directly

### Phase 2: AI Integration

**Goal**: Add AI-powered grouping suggestions.

1. **Implement AIGroupingService**
   (`background/tab-grouping/services/AIGroupingService.ts`)
   - Integrate with existing LLM providers (lib/llm/)
   - Generate grouping suggestions based on Goals
   - Handle AI errors gracefully

2. **Create AI prompts** for tab analysis
   - Design prompt template in service
   - Include Goal context and tab metadata
   - Parse structured JSON responses

3. **Add suggestion management**
   - Store pending suggestions
   - Handle accept/reject actions
   - Auto-expire old suggestions (24h)

4. **Write integration tests**
   - Mock LLM responses
   - Test suggestion generation with various tab sets
   - Verify expiration logic

**Verification**:

- Run `pnpm test tab-grouping/services/AIGroupingService` - all tests pass
- Manual: Create Goal, open related tabs, call generateSuggestions() in console,
  verify JSON response

### Phase 3: Undo/Redo System

**Goal**: Implement command pattern for undo/redo.

1. **Implement GroupingCommandService**
   (`background/tab-grouping/services/GroupingCommandService.ts`)
   - Command pattern with execute/undo/redo
   - In-memory undo/redo stacks (max 20 commands)
   - Support all command types: group, ungroup, rename, move, reorder

2. **Create command classes** for each operation type
   - Each command stores data and inverse data
   - Implement execute() and undo() methods

3. **Integrate with other services**
   - Wrap TabGroupService operations in commands
   - Push commands to stack on user actions

4. **Write unit tests**
   - Test each command type
   - Test undo/redo sequences
   - Test stack limits (20 commands)

**Verification**:

- Run `pnpm test tab-grouping/services/GroupingCommandService` - all tests pass
- Manual: Execute operations, undo, verify state restored, redo, verify state
  re-applied

### Phase 4: Message Handlers

**Goal**: Enable communication between UI and background services.

1. **Create message handlers**
   (`background/tab-grouping/handlers/message-handlers.ts`)
   - Handle all message types from contracts/api.md
   - Route to appropriate services
   - Return structured responses

2. **Register message listeners** in background script
   - Use Plasmo messaging patterns (@plasmohq/messaging)
   - Handle errors and send error responses

3. **Write integration tests**
   - Mock chrome.runtime.sendMessage
   - Test request/response flow
   - Verify error responses

**Verification**:

- Run `pnpm test tab-grouping/handlers` - all tests pass
- Manual: Send messages from options page console using
  chrome.runtime.sendMessage, verify responses

### Phase 5: UI Components

**Goal**: Build React components for options page.

1. **Install drag-drop library**
   - Add @dnd-kit/core and @dnd-kit/sortable to package.json
   - Run pnpm install

2. **Create base UI components**
   - `TabItem.tsx`: Display tab with favicon, title, drag handle
   - `TabGroupCard.tsx`: Display group with tabs, collapse/expand
   - `TabGroupList.tsx`: Virtualized list of all groups

3. **Create control components**
   - `GroupingControls.tsx`: Create group button, AI grouping trigger
   - `SuggestionCard.tsx`: Display AI suggestion with accept/reject buttons
   - `UndoRedoControls.tsx`: Undo/redo buttons with disabled states

4. **Add drag-and-drop logic**
   - Use DndContext from @dnd-kit/core
   - Handle onDragEnd for tab movements
   - Update group via message to background

5. **Write component tests**
   - Test rendering with various props
   - Test user interactions (click, drag events)
   - Mock message sending

**Verification**:

- Run `pnpm test tab-grouping/components` - all tests pass
- Visual review: Load extension, open options page, verify all components render

### Phase 6: Options Page Integration

**Goal**: Integrate tab grouping UI into options page.

1. **Modify options/index.tsx**
   - Add "Manage Tabs" section/tab
   - Import and render TabGroupList component
   - Add state management for groups and suggestions

2. **Add data fetching**
   - useEffect to load groups on mount
   - Send message to background: tab-grouping:get-all-groups
   - Update state with response

3. **Add event listeners**
   - Listen for group-created, group-updated, group-deleted events
   - Update UI state in real-time

4. **Add error handling and loading states**
   - Show loading spinner while fetching
   - Display error messages if operations fail

**Verification**:

- Manual: Open options page, navigate to "Manage Tabs", verify data loads
- Manual: Perform operations (create, delete, rename), verify real-time updates

### Phase 7: Permission Updates

**Goal**: Add required Chrome permissions.

1. **Update package.json manifest**
   - Add "tabGroups" to permissions array

2. **Reload extension**
   - Rebuild with pnpm dev
   - Reload in chrome://extensions

3. **Verify permissions**
   - Check chrome.tabGroups API is accessible in background script

**Verification**:

- Manual: Load extension, check no permission errors in console
- Manual: Call chrome.tabGroups.query() in background console, verify response

### Phase 8: End-to-End Testing

**Goal**: Comprehensive manual testing of full workflows.

1. **Test AI grouping workflow** (User Story 1 - P1)
   - Create Goal "Learn React"
   - Open 5 React tutorial tabs
   - Open 5 unrelated tabs
   - Trigger AI grouping
   - Accept suggestion
   - Verify tabs grouped correctly with colored tab groups in browser

2. **Test manual grouping workflow** (User Story 2 - P2)
   - Select 3 tabs in UI
   - Create group "Weekend Reading"
   - Drag tab from one group to another
   - Ungroup a tab
   - Rename a group
   - Verify all operations persist across page refresh

3. **Test manage tabs interface** (User Story 3 - P1)
   - Navigate to "Manage Tabs" in options
   - View all groups
   - Close all tabs in a group
   - Reorder groups by dragging
   - Verify changes reflected in browser tabs

4. **Test undo/redo** (FR-015)
   - Create a group
   - Undo → verify group removed
   - Redo → verify group restored
   - Perform sequence: create, rename, move tab, undo 3x, redo 3x

5. **Test persistence** (User Story 4 - P3)
   - Create multiple groups
   - Close browser
   - Reopen browser
   - Verify groups restored with correct tabs

6. **Test edge cases**
   - Create group with 50+ tabs (performance)
   - Test with 0 tabs open
   - Test with invalid tab IDs
   - Test AI grouping with no Goals
   - Test with incognito tabs

**Verification**:

- Manual: Follow each test scenario in quickstart.md section "Manual Testing
  Workflow"
- Document results in walkthrough.md after implementation

## Verification Plan

### Automated Tests

**Unit Tests** (Run: `pnpm test`)

- `tests/tab-grouping/services/TabGroupService.test.ts`
  - Test createGroup, updateGroup, deleteGroup, getAllGroups, moveTabToGroup
  - Mock chrome.tabs.group, chrome.tabGroups.update, storage APIs
  - Verify error handling for invalid inputs

- `tests/tab-grouping/services/AIGroupingService.test.ts`
  - Test generateSuggestions with mocked LLM responses
  - Test suggestion accept/reject/expiration
  - Verify Goal integration

- `tests/tab-grouping/services/TabMetadataService.test.ts`
  - Test metadata CRUD operations
  - Test pruneClosedTabs logic
  - Verify caching behavior

- `tests/tab-grouping/services/GroupingCommandService.test.ts`
  - Test each command type (group, ungroup, rename, move)
  - Test undo/redo stack management
  - Test stack size limits (20 commands)

- `tests/tab-grouping/components/TabGroupList.test.tsx`
  - Test rendering with empty/populated groups
  - Test drag-drop events (mocked)

- `tests/tab-grouping/components/GroupingControls.test.tsx`
  - Test button clicks trigger correct messages
  - Test disabled states

**Integration Tests** (Run: `pnpm test`)

- Test message handler integration with services
- Test storage persistence across service operations
- Test Chrome API wrapper integration

**Expected Results**: All tests pass with 0 failures. Coverage >80% for new
code.

### Manual Verification

**1. Basic Tab Grouping** (5 minutes)

1. Load extension in Chrome (chrome://extensions, Load unpacked →
   build/chrome-mv3-dev)
2. Open 5 tabs on different topics
3. Open extension options page
4. Navigate to "Manage Tabs" section
5. Click "Create Group", name it "Test Group", select 3 tabs
6. **Expected**: Tabs appear grouped in browser with colored tab group label
   "Test Group"
7. **Expected**: Group appears in options page UI with 3 tab items

**2. AI-Powered Grouping** (5 minutes)

1. Create Goal: "Learn TypeScript" in extension
2. Open 5 TypeScript tutorial/doc tabs
3. Open 3 random news tabs
4. In "Manage Tabs", click "AI Group Tabs" button
5. **Expected**: Suggestion appears: "Learn TypeScript" group with 5 tabs,
   confidence > 0.7
6. Click "Accept"
7. **Expected**: TypeScript tabs grouped in browser, news tabs remain ungrouped
8. **Expected**: Group name is "Learn TypeScript"

**3. Drag-and-Drop** (3 minutes)

1. With 2+ groups created in steps above
2. Drag a tab from "Test Group" to "Learn TypeScript" group in UI
3. **Expected**: Tab disappears from source group, appears in destination group
4. **Expected**: Chrome browser shows tab moved to new tab group
5. Refresh options page
6. **Expected**: Changes persist (tab still in destination group)

**4. Undo/Redo** (3 minutes)

1. Click "Undo" button in options page
2. **Expected**: Last operation (drag-drop) is reversed, tab back in original
   group
3. **Expected**: "Redo" button becomes enabled
4. Click "Redo"
5. **Expected**: Tab moves back to destination group
6. **Expected**: "Undo" button reflects new stack size

**5. Persistence Across Sessions** (5 minutes)

1. Note current groups and their tabs
2. Close Chrome completely
3. Reopen Chrome
4. Load extension options page → "Manage Tabs"
5. **Expected**: All groups restored with same names, colors, and tabs
6. **Expected**: Chrome browser shows tab groups match options page

**6. Edge Case: Large Tab Count** (5 minutes)

1. Open 100 tabs using script:
   `for(let i=0; i<100; i++) window.open('https://example.com')`
2. Trigger AI grouping
3. **Expected**: Operation completes within 5 seconds
4. **Expected**: UI remains responsive (60 fps scrolling)
5. **Expected**: No console errors

**Total Manual Testing Time**: ~26 minutes

### Acceptance Criteria Traceability

Maps functional requirements to verification methods:

| Requirement                                | Verification Method         |
| ------------------------------------------ | --------------------------- |
| FR-001: AI analyze and suggest groupings   | Manual Test #2              |
| FR-002: Manual/auto trigger AI grouping    | Manual Test #2              |
| FR-003: Manual group creation              | Manual Test #1              |
| FR-004: Drag-drop tabs                     | Manual Test #3              |
| FR-005: Ungroup tabs                       | Unit tests + Manual Test #2 |
| FR-006: Rename groups                      | Unit tests                  |
| FR-007: Delete groups                      | Unit tests                  |
| FR-008: Manage Tabs UI in options          | Manual Tests #1-5           |
| FR-009: Visual distinction of grouped tabs | Manual Tests #1-2           |
| FR-010: Persist across sessions            | Manual Test #5              |
| FR-011: Reorder groups                     | Unit tests + Manual Test #3 |
| FR-012: Close all tabs in group            | Unit tests                  |
| FR-013: Show visual indicators             | Manual Tests #1-2           |
| FR-014: Handle unmatched tabs              | Manual Test #2              |
| FR-015: Undo/redo functionality            | Unit tests + Manual Test #4 |

## Dependencies

**Existing**:

- Plasmo Framework 0.90.5 (Chrome extension framework)
- React 18.2.0, react-dom 18.2.0 (UI)
- TypeScript 5.3.3 (type safety)
- @plasmohq/storage 1.15.0 (storage abstraction)
- Vitest 4.0.16 (testing)
- @testing-library/react 16.3.1 (component testing)
- Existing Goals system (lib/types.ts, lib/storage.ts)
- Existing AI providers (lib/llm/)

**New Dependencies**:

- @dnd-kit/core ^6.1.0 (drag-and-drop core)
- @dnd-kit/sortable ^8.0.0 (sortable drag-and-drop items)

**Chrome APIs**:

- chrome.tabGroups (native tab grouping)
- chrome.tabs (tab management)
- chrome.storage.sync (cross-device storage)
- chrome.runtime (messaging)

## Risks & Mitigations

**Risk**: Chrome tabGroups API not available in older Chrome versions\
**Mitigation**: Check for API availability, show upgrade message if <Chrome 88.
Document minimum version in README.

**Risk**: AI grouping accuracy may be poor\
**Mitigation**: Include confidence scores, allow users to reject suggestions.
Collect feedback for improving prompts.

**Risk**: Performance degradation with 100+ tabs\
**Mitigation**: Implement lazy loading, virtualized lists (react-window if
needed), debounce updates, batch Chrome API calls.

**Risk**: Storage quota exceeded for users with many groups\
**Mitigation**: Implement group limit (50 groups), warn users nearing limit,
provide cleanup tools.

**Risk**: Drag-drop library compatibility issues\
**Mitigation**: Use well-maintained @dnd-kit, test thoroughly, have fallback to
button-based move operations.

## Next Steps

1. **Generate tasks**: Run `/speckit.tasks` to create actionable task breakdown
2. **Implementation**: Execute tasks in dependency order (Phase 1 → Phase 8)
3. **Continuous testing**: Run automated tests after each service/component
4. **Manual verification**: Perform manual tests at end of each phase
5. **Documentation**: Update walkthrough.md with implementation results

## References

- [Feature Specification](file:///Users/moment/Projects/personal/projects/saas/stop-read/specs/001-ai-tab-grouping/spec.md)
- [Technical Research](file:///Users/moment/Projects/personal/projects/saas/stop-read/specs/001-ai-tab-grouping/research.md)
- [Data Model](file:///Users/moment/Projects/personal/projects/saas/stop-read/specs/001-ai-tab-grouping/data-model.md)
- [API Contracts](file:///Users/moment/Projects/personal/projects/saas/stop-read/specs/001-ai-tab-grouping/contracts/api.md)
- [Quick Start Guide](file:///Users/moment/Projects/personal/projects/saas/stop-read/specs/001-ai-tab-grouping/quickstart.md)
- [STOPRead Constitution](file:///Users/moment/Projects/personal/projects/saas/stop-read/.specify/memory/constitution.md)
